from collections import deque
start = ['E','E','E','_','W','W','W']
goal  = ['W','W','W','_','E','E','E']

def successors(board):
    succs = []
    n = len(board)
    for i, r in enumerate(board):
        if r == 'E':
            # step
            if i+1 < n and board[i+1] == '_':
                new = board.copy(); new[i], new[i+1] = '_','E'; succs.append(new)
            # jump
            if i+2 < n and board[i+1] in ('E','W') and board[i+2] == '_':
                new = board.copy(); new[i], new[i+2] = '_','E'; succs.append(new)
        elif r == 'W':
            if i-1 >= 0 and board[i-1] == '_':
                new = board.copy(); new[i], new[i-1] = '_','W'; succs.append(new)
            if i-2 >= 0 and board[i-1] in ('E','W') and board[i-2] == '_':
                new = board.copy(); new[i], new[i-2] = '_','W'; succs.append(new)
    return succs

def bfs(start, goal):
    q = deque([(start, [start])])
    visited = set([tuple(start)])
    while q:
        state, path = q.popleft()
        if state == goal:
            return path
        for s in successors(state):
            t = tuple(s)
            if t not in visited:
                visited.add(t)
                q.append((s, path + [s]))
    return None

if __name__ == "__main__":
    path = bfs(start, goal)
    if path:
        print("Moves needed:", len(path)-1)
        for i, board in enumerate(path):
            print(f"{i}: {''.join(board)}")
    else:
        print("No solution found")
